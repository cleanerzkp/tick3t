import { prove } from "../prover.js";
import { createExtensionWebProofProvider } from "../webProof/index.js";
import { decodeFunctionResult, } from "viem";
import { ZkProvingStatus } from "../../web-proof-commons/index.js";
function dropEmptyProofFromArgs(args) {
    if (Array.isArray(args)) {
        return args.slice(1);
    }
    return [];
}
function generateRandomHash() {
    let hash = "0x";
    for (let i = 0; i < 40; ++i) {
        hash += Math.floor(Math.random() * 16).toString(16);
    }
    return hash;
}
async function getHash() {
    return Promise.resolve(generateRandomHash());
}
export const createVlayerClient = ({ url = "http://127.0.0.1:3000", webProofProvider = createExtensionWebProofProvider(), } = {
    url: "http://127.0.0.1:3000",
    webProofProvider: createExtensionWebProofProvider(),
}) => {
    const resultHashMap = new Map();
    return {
        prove: async ({ address, functionName, chainId, proverAbi, args }) => {
            webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Proving);
            const result_promise = prove(address, proverAbi, functionName, args, chainId, url)
                .catch((error) => {
                webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Error);
                throw error;
            })
                .then((result) => {
                webProofProvider.notifyZkProvingStatus(ZkProvingStatus.Done);
                return result;
            });
            const hash = await getHash();
            resultHashMap.set(hash, [result_promise, proverAbi, functionName]);
            return { hash };
        },
        waitForProvingResult: async ({ hash, }) => {
            const savedProvingData = resultHashMap.get(hash);
            if (!savedProvingData) {
                throw new Error("No result found for hash " + hash);
            }
            const [result_promise, proverAbi, functionName] = savedProvingData;
            const { result: { proof, evm_call_result }, } = await result_promise;
            const result = dropEmptyProofFromArgs(decodeFunctionResult({
                abi: proverAbi,
                data: evm_call_result,
                functionName,
            }));
            return [proof, ...result];
        },
    };
};
